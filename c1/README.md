# Chapter 1
## Core

## Question
- Lifetime Varianceの節あまり良くわからなかった
  - &mut T は不変性(invariance)を持つのでTそのものが必要... 本当にそうなのだろうか？
## Memo
- rustの基礎を固めるための章
- rustについて知るために、メモリについて解説する
- valueとvariableとpointerの違いについて
  - value
    - ある型とその型の値の領域の組み合わせ
    - どこに格納されているかによって、valueの意味は変わらない
  - variable
    - valueの格納先
    - スタック上の名前付きvalue格納庫
  - pointer
    - メモリ上の住所を示すvalue
- constとは
  - constで宣言した値は，プログラム内の参照箇所でその値に置き換えられる
- スタック
  - 呼び出された関数のローカル変数・引数・戻り値などが置かれる
  - 関数が戻るとスタックは片付けられる
- ヒープ
  - スタックに紐付かないメモリプール
  - RustではBoxを使って扱う
- Rustコンパイラは、参照した値が変更されないことを保証する
- mutableの参照先の値の移動はできるが、参照先に何らかの値を残すべきという制約がある。
  - そのため、takeやswapを使った移動はok，`let x = *p`による移動は不可
- varinance(変性)とは
  - 任意の型Tに対してどのような性質を持つか示したもの，4種類ある
    - 不変性(invariance): Tそのものが必要
    - 共変性(covariance): Tそのものかサブタイプ
    - 反変性(contravariance): Tそのもの，スーパータイプが必要
    - 双変性(bivariance): Tそのもの，スーパータイプ，サブタイプが必要
  - 型Tに対してTのサブタイプを割り当てることができる
    - 例: i: i32な変数に対してサブタイプである10を割り当てる
    - 例: i: Animalな変数に対してサブタイプであるTurtleのインスタンスを割り当てる
  - 逆にスーパータイプを割り当てることはできない
    - 例: i: Turtleな変数にスーパータイプであるAnimalを割り当てるのは不可
  - オブジェクト，配列は共変
  - 関数は，返り値に対して共変
    - 少なくともBのサブクラスを返すことを約束する
  - 関数は，引数に関して反変
    - 関数内で引数に対するメソッドを必ず呼び出すことができることを保証する
    - 双変性を持つとすると以下のような不具合が起きる
      - A, B extends A, C extends Bという3つの型があるとする．それぞれmethodA, B, Cを実装している
      - type TakeB = (arg: B) => void
      - const func = (f: TakeB) => {const b = new B(); f(b);}; のような関数を定義し
      - const callMethodC = (c: C) => {c.methodC();};
      - func(callMethodC)を呼ぶと，bはcのサブクラスではないためエラーとなってしまう．
